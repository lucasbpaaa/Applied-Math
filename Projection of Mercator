                    # Plot Brazil map on sphere:

[X, Y, Z] = sphere(40); #sphere
mesh(X, Y, Z)
hold on

B = load("border_main.txt");

lon = B(:,1)*(pi/180);  
lat = B(:,2)*(pi/180);   

Xmap = cos(lat) .* cos(lon);
Ymap = cos(lat) .* sin(lon);
Zmap = sin(lat);

plot3(Xmap, Ymap, Zmap, '-') 

                          #Plot Brazil map on Mercator:

Xbr_m = lon;
Ybr_m = log(tan(lat/2 + pi/4));

#plot(Xbr_m,Ybr_m,'r','LineWidth',2);


                          #Loxodromia on Mercator Plane:


lat_RJ = -22.9035*(pi/180); 
lon_RJ = -43.2096*(pi/180); 

lat_BRIS = -27.47*(pi/180); 
lon_BRIS = 153.03*(pi/180);

x_BRISm = lon_BRIS;
x_RJm =  lon_RJ;

y_BRISm = log(tan(lat_BRIS/2 + pi/4));
y_RJm = log(tan(lat_RJ/2 + pi/4));

m = (y_BRISm - y_RJm)/(x_BRISm - x_RJm);

x = linspace(x_RJm, x_BRISm, 1000);
y = m*(x - x_RJm) + y_RJm;

#plot(x,y,'r','LineWidth',2);


                               #Loxodromia on sphere:

phi = 2*atan(exp(y)) - pi/2;  
lambda = x;     
             
X_lox = cos(phi) .* cos(lambda);
Y_lox = cos(phi) .* sin(lambda);
Z_lox = sin(phi);

plot3(X_lox,Y_lox,Z_lox,'r','LineWidth',2);


                                #Geodesic on sphere:

x_RJ = cos(lat_RJ) .* cos(lon_RJ);
y_RJ = cos(lat_RJ) .* sin(lon_RJ);
z_RJ = sin(lat_RJ);

x_BRIS = cos(lat_BRIS) .* cos(lon_BRIS);
y_BRIS = cos(lat_BRIS) .* sin(lon_BRIS);
z_BRIS = sin(lat_BRIS);

p = [x_RJ; y_RJ; z_RJ];
q = [x_BRIS; y_BRIS; z_BRIS];

m = 1000;
theta = acos(dot(p,q));
t = linspace(0, 1, m);
Gamma = zeros(3, m);


for k= 1:m
  Gamma(:,k) = ( sin((1-t(k))*theta)*p + sin(t(k)*theta)*q ) / sin(theta);
end

#plot3(Gamma(1,:), Gamma(2,:), Gamma(3,:), 'b', 'LineWidth', 2);



                    #Geodesic using non-parametric equation:

v = 1000;
normal = cross(p, q);
Phi = zeros(1,v);

Lambda = linspace(lon_RJ, lon_BRIS - 2*pi, v);

Phi = atan((-normal(1).*cos(Lambda) - normal(2).*sin(Lambda))/normal(3));

x_g = cos(Phi) .* cos(Lambda);
y_g = cos(Phi) .* sin(Lambda);
z_g = sin(Phi);

#plot3(x_g, y_g, z_g,'k','LineWidth',2);



                            #Geodesic on Mercator:

ph = asin(Gamma(3,:));
lamb = angle(Gamma(1,:) + 1i*Gamma(2,:));

ph_m = log(tan(pi/4 + ph/2));

# ----- When longitude near pi, we have a descontinuity. Observe that lamb \in...
... (-pi, pi), so the parameter jumps to -pi to pi and the code build a horizontal...
... line. The code bellow removes this line. -----------


if !isempty(jump_idx)
    
    for i = flip(jump_idx)
        lamb_m = [lamb(1:i), NaN, lamb(i+1:end)];
        ph_m = [ph_m(1:i), NaN, ph_m(i+1:end)];
    end
end

# --------------------------------------------------------------

plot(lamb_m, ph_m, 'r', 'LineWidth', 2);



                  #Trapezoidal method and Brazil lenght:

                  
H = [Xmap(:), Ymap(:), Zmap(:)]; #These parameters were defined at the...
                          ... beginning of the code.
H(end+1,:) = H(1,:);
dot_prod = sum(H(1:end-1,:) .* H(2:end,:), 2);
dot_prod = min(1, max(-1, dot_prod)); #Numerical safety
R = 6371;

S_br = sum(R*acos(dot_prod)); #Total lenght of Brazil boundary.



                              #GPS
                              
file = Lets_go_IMPA.gpx                         
function total_km = comprimento_gpx(file)

    xDoc = xmlread(file);
    trkpts = xDoc.getElementsByTagName("trkpt"); #elements represent track points
    n = trkpts.getLength(); #number of points in the track

    lati = zeros(n,1);
    longit = zeros(n,1);

    for i = 1:n
        node = trkpts.item(i-1);
        lati(i) = str2double(node.getAttribute("lat"));
        longit(i) = str2double(node.getAttribute("lon"));
    end

   
    R = 6371;  

    lat1 = lati(1:end-1) * pi/180;
    lon1 = longit(1:end-1) * pi/180;
    lat2 = lati(2:end) * pi/180;
    lon2 = longit(2:end) * pi/180;

    dlat = lat2 - lat1;
    dlon = lon2 - lon1;

    a = sin(dlat/2).^2 + cos(lat1).*cos(lat2).*sin(dlon/2).^2;
    c = 2 * atan2(sqrt(a), sqrt(1-a));

    d = R * c;

    # --- Total lenght---
    total_km = sum(d);

    fprintf("Comprimento do trajeto: %.3f km\n", total_km)
end
        
