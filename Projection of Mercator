                    # Plot Brazil map on sphere:

[X, Y, Z] = sphere(40); #sphere
mesh(X, Y, Z)
hold on

B = load("border_main.txt");

lon = B(:,1)*(pi/180);  
lat = B(:,2)*(pi/180);   

Xmap = cos(lat) .* cos(lon);
Ymap = cos(lat) .* sin(lon);
Zmap = sin(lat);

plot3(Xmap, Ymap, Zmap, '-') 

                          #Plot Brazil map on Mercator:

Xbr_m = lon;
Ybr_m = log(tan(lat/2 + pi/4));

plot(Xbr_m,Ybr_m,'r','LineWidth',2);


                          #Loxodromia on Mercator Plane:


lat_RJ = -22.9035*(pi/180); 
lon_RJ = -43.2096*(pi/180); 

lat_BRIS = -27.47*(pi/180); 
lon_BRIS = 153.03*(pi/180);

x_BRISm = lon_BRIS;
x_RJm =  lon_RJ;

y_BRISm = log(tan(lat_BRIS/2 + pi/4));
y_RJm = log(tan(lat_RJ/2 + pi/4));

m = (y_BRISm - y_RJm)/(x_BRISm - x_RJm);

x = linspace(x_RJm, x_BRISm, 1000);
y = m*(x - x_RJm) + y_RJm;

plot(x,y,'r','LineWidth',2);


                               #Loxodromia on sphere:

phi = 2*atan(exp(y)) - pi/2;  
lambda = x;     
             
X_lox = cos(phi) .* cos(lambda);
Y_lox = cos(phi) .* sin(lambda);
Z_lox = sin(phi);

plot3(X_lox,Y_lox,Z_lox,'r','LineWidth',2);


                                #Geodesic on sphere:

x_RJ = cos(lat_RJ) .* cos(lon_RJ);
y_RJ = cos(lat_RJ) .* sin(lon_RJ);
z_RJ = sin(lat_RJ);

x_BRIS = cos(lat_BRIS) .* cos(lon_BRIS);
y_BRIS = cos(lat_BRIS) .* sin(lon_BRIS);
z_BRIS = sin(lat_BRIS);

p = [x_RJ; y_RJ; z_RJ];
q = [x_BRIS; y_BRIS; z_BRIS];

m = 1000;
theta = acos(dot(p,q));
t = linspace(0, 1, m);
Gamma = zeros(3, m);


for k= 1:m
  Gamma(:,k) = ( sin((1-t(k))*theta)*p + sin(t(k)*theta)*q ) / sin(theta);
end

plot3(Gamma(1,:), Gamma(2,:), Gamma(3,:), 'b', 'LineWidth', 2);



                    #Geodesic using non-parametric equation:

v = 1000;
normal = cross(p, q);
Phi = zeros(1,v);

Lambda = linspace(lon_RJ, lon_BRIS - 2*pi, v);

Phi = atan((-normal(1).*cos(Lambda) - normal(2).*sin(Lambda))/normal(3));

x_g = cos(Phi) .* cos(Lambda);
y_g = cos(Phi) .* sin(Lambda);
z_g = sin(Phi);

plot3(x_g, y_g, z_g,'k','LineWidth',2);



                         #Geodesic on Mercator:

ph = asin(Gamma(3,:));
lamb = angle(Gamma(1,:) + 1i*Gamma(2,:));

ph_plot = log(tan(pi/4 + ph/2));

# ----- When longitude near pi, we have a descontinuity. Observe that lamb \in...
... (-pi, pi), so the parameter jumps to -pi to pi and the code build a horizontal...
... line. The code bellow removes this line. -----------


lamb_plot = mod(lamb + pi, 2*pi) - pi;

#To Find where the longitude "jumps" ...
... we look for differences greater than pi between consecutive points
diffs = abs(diff(lamb_plot));
jump_idx = find(diffs > pi);

if !isempty(jump_idx)
    
    for i = flip(jump_idx)
        lamb_plot = [lamb_plot(1:i), NaN, lamb_plot(i+1:end)];
        ph_plot = [ph_plot(1:i), NaN, ph_plot(i+1:end)];
    end
end

# --------------------------------------------------------------

plot(lamb_plot, ph_plot, 'r', 'LineWidth', 2);



                  #Trapezoidal method and Brazil lenght:

                  
H = [Xmap(:), Ymap(:), Zmap(:)]; #These parameters were defined at the...
                          ... beginning of the code.
H(end+1,:) = H(1,:);
dot_prod = sum(H(1:end-1,:) .* H(2:end,:), 2);
dot_prod = min(1, max(-1, dot_prod)); #Numerical safety
R = 6371;

S_br = sum(R*acos(dot_prod)); #Total lenght of Brazil boundary.
fprintf("Total lenght of Brazil boundary: %.3f km\n", S_br);




                                    #GPS

filename = 'Lets_go_IMPA.gpx';
text = fileread(filename);

#Extract Latitudes and Longitudes:
 
latit = str2double(regexp(text, '(?<=lat=")[^"]+', 'match'));
longitu = str2double(regexp(text, '(?<=lon=")[^"]+', 'match'));

lat_rad = latit * (pi/180);
lon_rad = longitu * (pi/180);

#Calculate differences between consecutive datas
dphi = diff(lat_rad);
dlam = diff(lon_rad);

# We define the average latitude for each segment to scale the longitude
...correctly (Using the points from 1 to N-1 and 2 to N)

phi_avg = (lat_rad(1:end-1) + lat_rad(2:end)) / 2;

R = 6371000;

# Calculate the arc lengths as requested:
L_phi = R .* dphi;
L_lambda = R .* dlam .* cos(phi_avg);

distances = sqrt(L_phi.^2 + L_lambda.^2);



                            #Total lenght: 

total_km = sum(distances) / 1000;


fprintf('Total Route Length: %.2f km\n', total_km);



                          #Finding velocity graph:

phi_avg_global = mean(lat_rad); 
l_lamb = R .* lon_rad .* cos(phi_avg_global); 
l_phi = R .* lat_rad;                       

N = 3; 
vx = zeros(size(l_lamb));
vy = zeros(size(l_phi));
dt = 1; 

# The Loop (Moving Polynomial Fit)
# We start at N+1 so we have enough points behind us
for i = (N + 1) : (length(l_lamb) - N)
    # Extracting the linear coefficient 'b'
    sum_l_lamb = -3*l_lamb(i-3) - 2*l_lamb(i-2) - 1*l_lamb(i-1) + 0*l_lamb(i) + ...
                  1*l_lamb(i+1) + 2*l_lamb(i+2) + 3*l_lamb(i+3);
                  
    sum_l_phi = -3*l_phi(i-3) - 2*l_phi(i-2) - 1*l_phi(i-1) + 0*l_phi(i) + ...
                 1*l_phi(i+1) + 2*l_phi(i+2) + 3*l_phi(i+3);
    
    vx(i) = sum_l_lamb / (28 * dt);
    vy(i) = sum_l_phi / (28 * dt);
end

speed_ms = sqrt(vx.^2 + vy.^2)*3.6;


figure; 
plot(speed_kmh(N+1 : end-N), 'LineWidth', 1.5);
ylim([0, 100]);
grid on;
ylabel('Speed (km/h)');
xlabel('Time (s)');
title('Velocity to IMPA (Linear Coefficient b of Local Quadratic Fit)');



                            #Route

figure;
plot(l_lamb, l_phi, 'b', 'LineWidth', 2);
grid on;
axis equal;    

xlabel('Easting - l_{\lambda} (km)');
ylabel('Northing - l_{\phi} (km)');
title('Route to IMPA');
hold on;
plot(l_lamb(1), l_phi(1), 'k', 'MarkerSize', 20, 'MarkerFaceColor', 'k'); 
plot(l_lamb(end), l_phi(end), 'r', 'MarkerSize', 20, 'MarkerFaceColor', 'r'); 
legend('Trajectory', 'Start', 'End');             
                        

