#Accuracy depending on the number of points sampled using Monte Carlo Method (value of pi).

n = round(logspace(2, 6, 100));
E_N = zeros(1, length(n));

for i = 1:length(n)
    a = n(i);
    x = rand(a, 1);
    y = rand(a, 1);
    
    in_circle = sum(x.^2 + y.^2 <= 1);
    PI = 4*in_circle/a;
    E_N(i) = abs(pi - PI);

end


loglog(n, E_N, 'r.', 'MarkerSize', 5)
hold on;

# Polyfit
p = polyfit(log10(n), log10(E_N), 1);
slope = p(1);
intercept = p(2);

E_fit = 10^intercept * n.^slope;
loglog(n, E_fit, 'b-', 'LineWidth', 2)
grid on

fprintf('Estimated slope = %.4f\n', slope);


#Solver PIP:

function inside = is_in_polygon(tx, ty, filename)
    
    % Load data using the variable 'filename'
    data = load(filename);
    
    px = data(:, 1);
    py = data(:, 2);
    
    % Duplicate start point at the end of the matrix to close the polygon
    px = [px; px(1)];
    py = [py; py(1)];
    
    n = length(px);
    inside = false;
    
    for i = 1:(n-1)
        x1 = px(i);   y1 = py(i);    
        x2 = px(i+1); y2 = py(i+1);   
        
        % Check if the point 'ty' is vertically within the edge's Y-range
        if ((y1 > ty) ~= (y2 > ty))
            x_int = x1 + (ty - y1) * (x2 - x1) / (y2 - y1);
            
            if (tx < x_int)
                inside = ~inside;
            end
        end
    end
end

# ------ Test to function is_in_polygon: -----

#Test Script for is_in_polygon:

filename = 'Test_of_is_in_polygon.txt';


tx = input('Enter test X coordinate: ');
ty = input('Enter test Y coordinate: ');


result = is_in_polygon(tx, ty, filename);

if result
    fprintf('\n[RESULT] The point (%.2f, %.2f) is INSIDE.\n', tx, ty);
else
    fprintf('\n[RESULT] The point (%.2f, %.2f) is OUTSIDE.\n', tx, ty);
end

#-------- The test ends here -------




# ----- Here, we have a draft of the code to calculate Brazil area using random points in sphere and the PIP function -------

pkg load statistics

N = 10000;                     
R = 6371;                      
filename = 'border_main.txt'; 

#Generating random points on sphere:
rdm_matrix = mvnrnd([0, 0, 0], eye(3), N);
count_inside = 0;

for j = 1:N
   
    u = rdm_matrix(j, 1);
    v = rdm_matrix(j, 2);
    w = rdm_matrix(j, 3);
    n_val = sqrt(u^2 + v^2 + w^2);
    
    qx = u/n_val;
    qy = v/n_val;
    qz = w/n_val;
    
 
    lat = asin(qz);
    lon = angle(qx + 1i*qy);
    
    # PIP Solver Check
    
    if is_in_polygon(lon, lat, filename)
        count_inside = count_inside + 1;
    end
end

# 5. Area Calculation

total_sphere_area = 4 * pi * R^2;
brazil_area_est = (count_inside / N) * total_sphere_area;

fprintf('Points analyzed: %d\n', N);
fprintf('Points found inside Brazil border: %d\n', count_inside);
fprintf('Estimated Area of Brazil: %.2f km^2\n', brazil_area_est);


# ----- I need adjust PIP to take a loxodromia ( or geodesic ) between two points of the Brazil map and to check which random points is inside to Brazil ----
