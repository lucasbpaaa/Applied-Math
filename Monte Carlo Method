            #Accuracy depending on the number of points sampled using...
                ... Monte Carlo Method (value of pi).

n = round(logspace(2, 6, 100));
E_N = zeros(1, length(n));

for i = 1:length(n)
    a = n(i);
    x = rand(a, 1);
    y = rand(a, 1);
    
    in_circle = sum(x.^2 + y.^2 <= 1);
    PI = 4*in_circle/a;
    E_N(i) = abs(pi - PI);

end


loglog(n, E_N, 'r.', 'MarkerSize', 5)
hold on;

# Polyfit
p = polyfit(log10(n), log10(E_N), 1);
slope = p(1);
intercept = p(2);

E_fit = 10^intercept * n.^slope;
loglog(n, E_fit, 'b-', 'LineWidth', 2)
grid on

fprintf('Angular coefficient of the line = %.4f\n', slope);



# ------------Test Script for is_in_polygon: ---------

filename = 'Test_of_is_in_polygon.txt';


tx = input('Enter test X coordinate: ');
ty = input('Enter test Y coordinate: ');


result = is_in_polygon(tx, ty, filename);

if result
    fprintf('\n[RESULT] The point (%.2f, %.2f) is INSIDE.\n', tx, ty);
else
    fprintf('\n[RESULT] The point (%.2f, %.2f) is OUTSIDE.\n', tx, ty);
end

#-------- The test ends here -------



#                                    Brazil area:


N = 10000;                     
R = 6371;                      
filename = 'border_main.txt';

# Longitude bounds
lon_min_rad = -74 * pi/180;
lon_max_rad = -35 * pi/180;


# --- Uniform sampling on the spherical lune ---

lon_rad = lon_min_rad + (lon_max_rad - lon_min_rad) .* rand(N,1);

sin_lat = 2 .* rand(N,1) - 1;
lat_rad = asin(sin_lat);

# Convert to degrees
lon_deg = lon_rad * 180/pi;
lat_deg = lat_rad * 180/pi;

# --- PIP test  ---

count_inside = 0;
for i = 1:N
    if is_in_polygon(lon_deg(i), lat_deg(i), filename)
        count_inside = count_inside + 1;
    end
end

                # --- Area calculation ---

delta_lon = lon_max - lon_min;

area_lune = 2 * R^2 * delta_lon; 

area_brazil = (count_inside / N) * area_lune;

fprintf('\n--- Calculation Complete ---\n');
fprintf('Points Inside Brazil: %d\n', count_inside);
fprintf('Total Samples: %d\n', N);
fprintf('Estimated Area: %.2f kmÂ²\n', area_brazil);
