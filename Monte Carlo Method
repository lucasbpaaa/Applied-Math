#Accuracy depending on the number of points sampled using Monte Carlo Method (value of pi).

n = round(logspace(2, 6, 100));
E_N = zeros(1, length(n));

for i = 1:length(n)
    a = n(i);
    x = rand(a, 1);
    y = rand(a, 1);
    
    in_circle = sum(x.^2 + y.^2 <= 1);
    PI = 4*in_circle/a;
    E_N(i) = abs(pi - PI);

end


loglog(n, E_N, 'r.', 'MarkerSize', 5)
hold on;

# Polyfit
p = polyfit(log10(n), log10(E_N), 1);
slope = p(1);
intercept = p(2);

E_fit = 10^intercept * n.^slope;
loglog(n, E_fit, 'b-', 'LineWidth', 2)
grid on

fprintf('Estimated slope = %.4f\n', slope);


#Solver PIP:

function inside = is_in_polygon(tx, ty, filename)
    
    % Load data using the variable 'filename'
    data = load(filename);
    
    px = data(:, 1);
    py = data(:, 2);
    
    % Duplicate start point at the end of the matrix to close the polygon
    px = [px; px(1)];
    py = [py; py(1)];
    
    n = length(px);
    inside = false;
    
    for i = 1:(n-1)
        x1 = px(i);   y1 = py(i);    
        x2 = px(i+1); y2 = py(i+1);   
        
        % Check if the point 'ty' is vertically within the edge's Y-range
        if ((y1 > ty) ~= (y2 > ty))
            x_int = x1 + (ty - y1) * (x2 - x1) / (y2 - y1);
            
            if (tx < x_int)
                inside = ~inside;
            end
        end
    end
end

# ------ Test to function is_in_polygon: -----

#Test Script for is_in_polygon:

filename = 'Test_of_is_in_polygon.txt';


tx = input('Enter test X coordinate: ');
ty = input('Enter test Y coordinate: ');


result = is_in_polygon(tx, ty, filename);

if result
    fprintf('\n[RESULT] The point (%.2f, %.2f) is INSIDE.\n', tx, ty);
else
    fprintf('\n[RESULT] The point (%.2f, %.2f) is OUTSIDE.\n', tx, ty);
end

#-------- The test ends here -------



#Generating random points on sphere:

pkg load statistics

N = 1000;
rdm_matrix = mvnrnd([0, 0, 0], eye(3), N); # mvnrnd(average, identity, number of random points)

X = zeros(N, 1);
Y = zeros(N, 1);
Z = zeros(N, 1);

for j = 1:N #projection on sphere
  u = rdm_matrix(j, 1);
  v = rdm_matrix(j, 2);
  w = rdm_matrix(j, 3);
  n = sqrt(x^2 + y^2 + z^2);
  X(j) = u/n;
  Y(j) = v/n;
  Z(j) = w/n;
end 

#plot3(X,Y,Z,'.')
axis equal


phi = asin(Z);
lambda = angle(X + 1i*Y);
