#Accuracy depending on the number of points sampled using...
... Monte Carlo Method (value of pi).

n = round(logspace(2, 6, 100));
E_N = zeros(1, length(n));

for i = 1:length(n)
    a = n(i);
    x = rand(a, 1);
    y = rand(a, 1);
    
    in_circle = sum(x.^2 + y.^2 <= 1);
    PI = 4*in_circle/a;
    E_N(i) = abs(pi - PI);

end


loglog(n, E_N, 'r.', 'MarkerSize', 5)
hold on;

# Polyfit
p = polyfit(log10(n), log10(E_N), 1);
slope = p(1);
intercept = p(2);

E_fit = 10^intercept * n.^slope;
loglog(n, E_fit, 'b-', 'LineWidth', 2)
grid on

fprintf('Estimated slope = %.4f\n', slope);


#Solver PIP:

function inside = is_in_polygon(tx, ty, filename)
    
    % Load data using the variable 'filename'
    data = load(filename);
    
    px = data(:, 1);
    py = data(:, 2);
    
    % Duplicate start point at the end of the matrix to close the polygon
    px = [px; px(1)];
    py = [py; py(1)];
    
    n = length(px);
    inside = false;
    
    for i = 1:(n-1)
        x1 = px(i);   y1 = py(i);    
        x2 = px(i+1); y2 = py(i+1);   
        
        % Check if the point 'ty' is vertically within the edge's Y-range
        if ((y1 > ty) ~= (y2 > ty))
            x_int = x1 + (ty - y1) * (x2 - x1) / (y2 - y1);
            
            if (tx < x_int)
                inside = ~inside;
            end
        end
    end
end


#Test Script for is_in_polygon:

filename = 'Test_of_is_in_polygon.txt';


tx = input('Enter test X coordinate: ');
ty = input('Enter test Y coordinate: ');


result = is_in_polygon(tx, ty, filename);

if result
    fprintf('\n[RESULT] The point (%.2f, %.2f) is INSIDE.\n', tx, ty);
else
    fprintf('\n[RESULT] The point (%.2f, %.2f) is OUTSIDE.\n', tx, ty);
end

#-------- The test ends here -------




# ----- Here, we have a draft of the code to calculate Brazil area using...
...random points in sphere and the PIP function -------

pkg load statistics

N = 10000;                     
R = 6371;                      
filename = 'border_main.txt';

# Brazil's Longitude Bounds (in degrees)
lon_min = -74; 
lon_max = -35;
delta_lon_rad = (lon_max - lon_min) * (pi/180);

# Generating random points on sphere using the Gaussian method
rdm_matrix = mvnrnd([0, 0, 0], eye(3), N);
count_inside = 0;

for j = 1:N
    #Normalize the 3D vector to sit on the sphere surface
    u = rdm_matrix(j, 1);
    v = rdm_matrix(j, 2);
    w = rdm_matrix(j, 3);
    n_val = sqrt(u^2 + v^2 + w^2);
    
    qx = u/n_val;
    qy = v/n_val;
    qz = w/n_val;
    
    lat_deg = asin(qz) * (180/pi);
    lon_deg = angle(qx + 1i*qy) * (180/pi);
    
    #Check points that fall inside the "Fuse"
    if (lon_deg >= lon_min && lon_deg <= lon_max)
        # PIP Solver Check:
        if is_in_polygon(lon_deg, lat_deg, filename)
            count_inside = count_inside + 1;
        end
    end
end

                      #Area Calculation

area_fuse = 2 * (R^2) * delta_lon_rad;
area_brazil = (count_inside / N) * (4 * pi * R^2);

fprintf('\n--- Calculation Complete ---\n');
fprintf('Points Inside Brazil: %d\n', count_inside);
fprintf('Total Samples: %d\n', N);
fprintf('Estimated Area: %.2f kmÂ²\n', area_brazil);
